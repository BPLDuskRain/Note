# 软件工程
## 软件的定义
>**软件：程序+数据（数据结构）+文档**<br>程序：数据结构+算法<br>数据：配置（支撑程序运行）+吞吐数据<br>文档：开发文档（需求、设计说明书……）、管理文档（可行性研究、开发计划、测试计划……）、用户文档
### 软件的特征
1. 没有明显的制造过程，成本在开发上，复制容易
2. 更容易修改，但改动后质量并不容易保持
3. 手工开发
4. 软件工程环境对产品影响较大
5. 难以估计时间和工作量
6. 测试困难
7. 不会磨损，但会退化（跟不上时代），维护软件是添加新功能
>是产品也是工具
## 软件危机
### 概念
软件开发过程中的一系列严重问题：

    超预算、超时、质量低，不符合要求，难以管理、运行、维护
### ~~产生原因~~
难以产生一种概念完整性（大量设计者的理念混杂导致软件的高度复杂性）<br>软件固有的复杂性、一致性、易变性、不可见性
### ~~消除途径~~
1. 正确认识软件
2. 软件开发是一种组织良好、管理严密、人员协同配合、共同完成的工程项目
3. 推广开发软件的成功技术、方法和管理经验、使用更好的软件工程工具
4. 软工层面
   1. 提升单个工具，如各种IDE
   2. 使用体系化工具（CASE工具包）
## 软件工程概念和发展过程
### 软件工程的定义
软件工程是研究大型软件开发和维护的技术、方法、工具、环境和管理的工程学科。应用**系统化、规范化、可量化**的方法开发、运行、维护软件（即，运用工程化方法运用到软件）
### 目标
    低开发成本
    易于维护
    高可靠性
    高性能
    按时交付
### 三要素：工具、方法、过程
上三要素最终聚焦于软件质量
    
    过程：规定各项步骤和活动
    方法（结构化、面向对象）：完成项目的技术手段
    工具：为以上两者提供支持
#### 结构化方法
- 抽象、自顶向下、逐层细化：复杂问题分阶段进行
- 模块化：问题分解为模块
- 局部化：高内聚低耦合，即模块内紧密联系，模块间联系松散
- 一致性：整个系统的模块风格、设计策略一致、内部接口一致、软硬件接口一致、说明和系统行为一致
- 完备性：不丢失成分
- 可验证性：易检查、易测试、易评审
#### 面向对象方法
- 对象分解取代功能分解
- 信息隐蔽、数据封装
- 继承促进重用
- 消息传递（动态链接）
#### 原则
    阶段性生命周期，每个阶段都要有计划
    连续验证，越早发现错误修复成本越低（文档测试）
    坚持规范的产品控制
    现代编程工具实践
    清晰责任分配
    少而精的人
    坚持过程改进的承诺
## 软件过程
活动、任务、动作的集合
### 软件生命周期
定义——开发——运行维护

定义时期

    软件计划、可行性分析（能不能/值不值得）、需求分析
        计划任务书、可行性研究报告、需求规格说明书
开发时期

    软件设计、实现（构建）：程序编写、测试（单元、集成、验收）
        概要设计说明书、详细设计说明书、程序清单、测试/验收报告    
维护时期

    移交、安装部署、技术支持/维护（修BUG，功能变更、扩充，系统移植）
        维护记录

### 软件过程模型
软件全部开发过程、活动和任务框架的一种概括：是一种理想模型而不是现实
#### 传统过程模型
写了再改模式：编写代码——修改代码

    少量代码可以，但代码量一旦大起来很难查找错误
#### *瀑布模型*（基本型无反馈，对人员能力要求高，较为理想）

    可行性研究——需求分析——总体设计——详细设计——编码——单元测试——系统测试——验收检测——运行与维护
反馈层级越高，问题越严重，修改代价越大

适用：

    需求明确、稳定，技术成熟、流程固定、工程管理严格（军工、航天、医疗）
缺点：

    人力利用率低
    增加文档和交互工作量
    开发风险大
    早期错误发现晚
    不适应需求变化，灵活度低
#### V模型
在瀑布模型的基础上改变回馈策略

    单元测试——详细设计
    系统测试——总体设计
    验收测试——需求分析
    一一反馈并通过基本瀑布模型路径修改

#### *增量模型*
增量：

    满足用户需求的一个子集
需求分析——体系结构设计——增量设计（每轮用瀑布模型）

    增量测试时必须全部测试时确保原有功能不被影响

累加方式：增加新功能

迭代方式：在原有功能上改善增加

优点：

    适应需求（小需求也可以直接进行开发），用户学习成本也低
    产品再用率高、容易推动士气
    降低开发风险
    适用于：
        需求易变、尽早完成开发、难以一步到位、可分阶段交付的项目
缺点：

    增量规模难以控制
    软件需要开放式体系结构
    易退化成边做边改模式（增量强调做的时候不能改，改的时候不能做）
#### *原型模型*
原型是一个前期准备、或一个部分开发的产品：

    为定义需求服务，研究并选择技术方案

通过原型迭代，形成需求和规格

    明确并完善需求，研究选择技术方案
#### *螺旋模型*
制定计划——风险分析——实施工程——客户评价

    天然的增量，以瀑布模型为基础，风险驱动
#### 专用过程模型
尽量利用前人的结果
#### 统一过程模型（RUP）
尝试从传统软件过程挖掘出最好的特质和特征

并在发展过程中推出了UML（统一建模语言）


#### *敏捷开发过程*（迭代式、增量式）
价值观：

    个体和互动 高于 过程和工具
    可工作的软件 高于 详尽的文档
    客户合作 高于 合同谈判
    响应变化 高于 遵循计划
    并非右项无价值，但应认为左项更有价值
极限编程

    通过用户故事制订交付计划、确定本次迭代实现功能、分解任务、指定迭代计划、开发/集成/测试软件、发布、评估本版软件
        结对编程、代码共享、持续集成、测试驱动开发、每日站会

把最佳实践发挥到极致

并列争球法
    引入角色：产品负责人、主持人、开发团队
## 需求分析
### 可行性研究
作为项目第一步，确定问题是否能解决，并形成可行性研究报告

决定做还是不做

包括

    技术可行性：能实现吗？
        技术实用程度、合理程度
        基础软硬件的可用性、人员的工作基础
    经济可行性：经济效益有？
        估算开发和运维成本
        估算经济效益
    操作可行性：用户可以操作吗？
        用户类型、操作习惯等
    社会环境可行性：管理方面（法律、政策）可行？社会效益如何？
        专利法、著作权法、计算机软件保护条例、网络安全法等
### 需求分析过程管理
需求的定义：

    系统需要具有的功能性需求和非功能性需求
    需求需要清晰、简洁、一致、无二义性
1. 需求获取：确定来源、收集的方法

    来源一般来自系统涉众（用户、顾客、监管机构）

    挑战：

        用户难以描述需求
        分析人员难以理解需求
        需求变动不可避免
        竞争环境
2. 需求细化（分析/建模）

        梳理需求描述
        建立需求分析模型
        学习领域知识
        考虑相似项目的重用
**需求分析目标：建立需求分析模型**
#### 建模方法
场景模型——用例图和活动图<br>面向类的模型——类图<br>基于行为和模式的模型——顺序图和状态图<br>数据模型——数据字典、ER图等<br>面向流的模型——数据流图等
#### 需求描述（产出）
《软件需求规格说明书》SRS，包含了功能性需求和非功能性需求

    功能性需求：描述系统或产品应该做什么
    非功能性需求：
        性能需求
        可靠性和可用性
        接口需求
        约束
### 需求验证
有效性和完备性、一致性、现实性
### 需求变更
## 面向对象的需求分析模型
数据模型（对象模型）：定义了系统的对象——类图<br>行为模型（动态模型）：描述了系统的控制结构和交互次序——顺序图、状态图<br>功能模型：描述系统功能、映射——用例图、活动图
### 基于场景的静态建模——用例和用例图
用例：从参与者的角度查看系统功能 

用例应该是完整的、代表用户可见的功能，是参与者启动的

用例图：

    参与者：小火柴人（但并不代表都是人）
    用例：椭圆
    关联关系：实线/单向箭头（但均表示任意一方皆可收发信息）
    系统边界：系统是提供边界的黑盒子
#### 参与者和用例、用例和用例的关系
关联、泛化、包含、扩展

泛化Inheritance/继承Generalization

    体现继承关系（子用例往往可以代表父用例、且父用例可能抽象）
    泛化双方业务共享、指责共享
    箭头规格：——（空心三角）（子指向父）
包含Include（必须功能）

    基本用例分解成几个包含用例
    箭头规格：--《include》-->（基本指向包含用例）
    相当于是复用代码，提炼出了某些功能
扩展Extend（可选功能）

    扩展用例补充了基本用例
    箭头规格：--《extend》-->（扩展用例指向基本用例）
    扩展用例有条件执行而包含用例无条件执行
#### 创建初始用例
从主要用户的主要场景开始描述，列出特定参与者的功能/活动
#### 细化初始用例
对主要场景的操作给出额外的描述——用于创建次要场景
#### 编写正式用例
文字描述不可缺少，最有价值的是对每个用例的文字说明
### 基于场景的行为建模——活动图
活动图可以图形化显示用例的动作流、增加了许多用例图无法直接描述的细节

状态

    1. 开始状态（一个）
        实心圆，表示活动开始
    2. 终止状态（一个或多个）：
      1. 活动终止节点：大圆圈+实心圆，表示整个活动结束
      2. 流程终止节点（并非必须）：圆圈+十字叉，表示子流程结束
动作节点：

    操场状圆矩形，表示特定功能
        1. 文字描述：主谓宾格式（有泳道可省略主语）
        2. 表达式形式
        3. 函数形式
控制流（转换）：

    带箭头直线，表示活动顺序传递 
判定、分支、合并：

    菱形，表示可选线程（非此即彼） 
    一转多需要标识条件，多转一不需要
同步条：

    粗直线，表示并行，等待多个动作完成或同时执行多个动作
泳道：

    用于准确区分动作主体
### UML简介
统一标、面向对象、可视化、独立于过程、概念明确

是一种对系统建立模型的语言

需求掌握：

    用例图、活动图、顺序图、类图
        
## 软件设计
某系统或构件的体系结构、构件、接口和其他特性以及该过程的结果

    软件生命期中的一个活动
    软件编码的基础
    连接用户需求和软件技术的桥梁
### UML类图
注：不要过早陷入具体细节

类图：
    
    概念层类图：纯类名+方框
    说明层类图：有一些成员
    实现层类图：有属性类型、方法标签等

类的构成：
    
    顶部：类名（尽量有明确的名词含义）
        可带包名可不带
        斜体类名表示抽象类
    中间：属性（名词）
    下部：方法（动作）

    属性格式：

        可见性：+公有public #保护protected ~默认 -私有private
        约束说明：{readonly}只读
        静态：下划线

    操作语法：

        [可见性] 操作名 (参数列表) [:返回类型] [{特性}]
        + add (x : int) :int {readonly}
        用冒号拖尾数据类型
#### 类的关系

依赖（传参）use-a

        使用和被使用
        弱关联
            A--->B
            （A使用B作为局部变量、参数、返回值类型或调用B的静态方法，则称A依赖B）

关联（成员）has-a

        知道并可以调用（）成员变量

        单向关联    A——>B
            A拥有B
            单向关联容易建立和维护、但增加了耦合
        双向关联    A——B或A<——>B
            A拥有B，B拥有A
            双向关联不是衔尾蛇：在堆上，可能在对象内只存储了指针或引用
        关联属性不必在属性列出，直接连接即可
        关联名（动作）可选
        关联角色（名词）可选
        关联数量（数字）可选：（如A会关联n个B，B能被n个A关联）
        关联约束（大括号括起），可表示异或等关系
        关联类还可描绘关联的属性、操作（如一份合同）
   
聚合（成员）：特殊关联 has-a

    表示对象的整体和部分的关系（可以共享/可拆卸部件）
        A（空心菱形）——>B
组合（成员）：特殊聚合 contains-a/has-a

    强烈的所有权关系、相同的生存周期（不能共享、排他/整体不存在部分无意义）
        A（实心菱形）——>B

泛化（继承）is-a

        A——（空心三角形）B
    即继承关系
实现（接口）is-a

        A---（空心三角形）B
    即实现接口
从上至下耦合程度增加

有固定组合或一对一、一对多，关联较优，多对多、短暂链接则依赖较优；根据弱耦合高内聚的思想，依赖能实现倾向使用依赖
### UML顺序图
顺序图：按照消息/事件发生的顺序描述时间交换、动作（对应一个用例）

#### 四个元素：对象、生命线、激活条、消息
对象：参与者（火柴人）、对象（方框）

    参与者一般在两端（左端优先）
    对象按消息顺序或重要顺序排列
    对象的命名——对象名 对象名：类名 ：类名（不关心具体对象）
生命线（虚线）：表示存在

    末端叉叉表示消亡点（临时对象必需）
    在执行过程中创建的对象一般放在中间
激活条（矩形棒状）：表示当前时刻被触发，进入执行

    消息传递时会触发某个操作（调用接收者方法），则接收消息者被激活
    长短位置并无所谓，只是形式
消息（横向箭头、带编号）：
    
    可以用函数式描述：xx()
    可以用版型描述：《xx》
    消息也是一种对象
    简单消息（同步、异步）
    反身消息（自己调用自己）
    返回消息（通知，返回值等）


#### 建模过程
设置交互场景、识别对象、设置生命线、消息发布、设置激活期
### 软件设计概念
系统或构建的体系结构、构件和其他特性

类->构件->模块->子系统->系统

一种需求分析模型的结果可能会对多个设计模型产生影响，也可能被多个分析模型影响

#### 面向对象设计原则
模块化、抽象、信息隐藏、弱耦合、强内聚、可重用
#### 启发规则
1. 设计结果应该清晰易懂：用词一致、避免模糊定义、使用已有协议、减少消息数目
2. 继承结构深度适当：一次继承大量扩充不如多次继承少量扩充；继承深度过大也不好控制
3. 设计简单的类：类不要提供太多服务，会使接口复杂度增加、难以理解
4. 使用简单的协议和服务
5. 将设计变动至最小
### 设计模型
数据设计、体系结构/架构、接口设计、构件设计、部署设计

#### 数据设计

以客户/用户的数据视角，构建高层抽象的**数据模型和信息模型**

    数据建模手段：
        基本方法：数据字典、E-R图、类图
        数据结构：计算机组织、存储数据的方式
        数据库：基于数据结构组织、存储、管理数据
        数据仓库：更大规模有特殊组织的数据库
#### 体系结构

定义了软件的主要结构化元素之间的关系，提供软件的整体**视图、风格和模式**

    需要通过构件图、部署图、功能模块图等展现
#### 接口设计

描述了信息如何**流入**和**流出**系统，以及构件如何**通信**

    用户界面、外部接口、内部接口
#### 构件设计

描述构建的**内部细节**，定义了**数据结构、算法、接口**特征和分配的通信机制

    软件级构件为局部数据定义数据机构、为处理定义算法细节、定位允许访问的接口
#### 部署设计

    软件功能和子系统如何在支持软件的计算环境内进行分布

    节点：硬件资源（处理器、设备）
    连接：通信路径
概要设计

### 体系结构设计
#### 数据中心体系结构（星形）
数据存储位于中心、其他构件对其进行访问<br>以数据为中心、客户端软件互相没有交互，通过数据存储实现信息共享
#### 数据流体系结构（管道形）
管道——过滤器模式：过滤器独立工作，对上游的某种格式进行转换
#### 调用和返回体系结构（树形）
主程序拆分模块，交给子程序
#### 层次体系结构
用户操作按照从外到内的方向传导，越靠里越接近底层

MVC模式

    模型——视图——控制器
    实现前后端分离（界面/业务分离），降低耦合方便维护
### 构件级设计
开闭原则：开放可扩展、修改则封闭

    如检测器不依赖某种检测器，而是依赖检测接口
依赖倒置原则

    高层不应该依赖底层，而是都依赖于抽象类而非具体实现
Liskov原则

    基态导出的子类传递给构件仍然可以正确实现功能
接口分离原则
    
    多个专用接口优于一个通用接口
## 软件质量保证
### 质量概念
1. 符合规定的功能、性能需求（前期约定）
2. 符合文档的开发标准（明确标准）
3. 一些隐含特征，如易用性、可维护性（共性期望）

#### 软件缺陷
问题、错误、功能缺陷

    未实现功能
    未明确提到、但应该实现
    未提到功能
    不能出现的错误
    难以理解、不易使用、运行缓慢等问题
#### 三组影响因素
产品修改

    可理解性
    可维修性
    灵活性
    可测试性
产品转移

    可移植性
    可再用性
    互运行性
产品运行

    正确性
    健壮性
    效率
    完整/安全性
    可用性
    风险
### 质量保证
来自质量控制
#### 质量控制（QC）
验证产品结果和预期值是否一致
>QC重点关注产品本身，但在软件中关注结果往往为时已晚
#### 软件质量保证（QA）
通过提升软件过程的质量提升软件质量（假设：过程质量决定了产品质量）
>QA对分析、设计、开发、测试全程监测

    希望在每个阶段得到好的遵循、
    避免早期引入的缺陷使时间和成本成倍增加
    通过缺陷分析有助于过程改进
### 软件测试
在某种指定的条件下对系统/构件进行操作，并对其进行某些方面的评估，分析和应有结果之间的差异（软件缺陷）
#### 测试目标
追溯用户需求

    测试是发现 错误 而执行的
    好的测试应该能发现尚未发现的错误的测试方案
    成功的测试是发现了从未发现的错误的测试
#### 测试原则
测试时间：

    尽早进行：在需求阶段就可以制定测试计划、建立设计模型后可以设计详细测试方案、编码之前就可以设计所有测试工作
    TDD：测试引导开发，用测试用例引导开发进行
    测试除了动态测试代码、还有静态测试文档
设计测试用例：

    穷尽测试/完全测试是不可能的：输入量太多、执行路径太多等
    因此意图用最少的工作量和最少的时间发现最大数量的错误
#### 测试策略
测试计划、测试用例设计、测试执行、测试数据收集和评估、修复回归

测试分类

    测试属性：功能测试、非功能测试
    测试阶段：单元测试、集成测试、验收测试、系统测试
    测试视角：黑盒测试、白盒测试、灰盒测试
    产品基准点：阿尔法、贝塔、正式版本、回归测试
    是否运行程序：静态、动态测试
    类型、方法学：传统测试、面向对象测试
#### 黑盒测试（功能测试、数据驱动）
忽略系统内部，只关注输入和输出

在接口层面进行测试

用等价类设计测试用例

等价类划分法

    有效等价类
        对程序是合理的、有意义的输入
    无效等价类
        对程序不合理的、无意义的输入
划分原则

    若规定了范围，则范围内划为有效等价类，其他范围划为一个或多个无效等价类
    若定义了规则（正则表达式等），则不遵守的划为无效等价类
    若规定了枚举，则枚举外划为无效等价类

在测试时尽量用少的测试用例囊括多的有效等价类，而用多的测试用例一对一地测试无效等价类

边界值分析：认为出错的部分大量在边界上

    单侧边界
        闭区间：选择边界点和超出一个步长的点
        开区间：选择边界点和一个向内一个步长的点
    双侧边界作为两个单侧考虑
#### 白盒测试（结构测试、逻辑驱动、基于代码的测试）
考虑系统内部

    完全路径覆盖是困难的（路径爆炸）
控制结构测试

    基本路径测试、数据流测试、循环测试
逻辑覆盖测试

    语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖
流图（FLow Gragh）表示：

    先将代码转成流程图（Flow Chart），再简化成控制流图（CFG）
    只描述控制流程，不表示具体条件
    
    顺序结构：无分叉即可合并
    判定结点：红色
    汇聚结点：蓝色
    if-else：分叉后需要集合到汇聚结点（可以没有语句）
    while:判定——执行回路
    do-while：执行——判定回路
    switch-case：多分叉多集合
    域：边和结点圈定的封闭区域（里外各算一个域）
简化注意：

    开始结点——>删除
    结束结点——>必须体现，且多合一
    有分支就要有汇聚结点
结点覆盖（语句覆盖）：经过所有结点的路径

边覆盖：经过所有边的路径（组合）

路径覆盖：所有路径

条件覆盖：包含所有条件语句

路径覆盖一定是边覆盖、边覆盖一定是结点覆盖

基本路径测试：指标——环路复杂性V(G)，定义执行路径的基本集合

环路复杂度（三种方法计算）

$V(G)=E-N+2$；E：边，N：结点

$V(G)=P+1$；P：判定结点数

$V(G)=Num(R)$；即域的数量

基本集合

    独立性：至少引入了新条件/新语句（相对已有条件）
    完备性：再多一条任何路径都不会加入新条件
    基本路径数量不会比环路复杂度更大

    从入口到出口作为第一条路径
    依次在每个判定结点翻转
#### 灰盒测试

    介于上述二者之间（程序探针）
#### 软件测试策略V模型
    系统测试
    需求分析————验收测试
    概要设计————集成测试
    详细设计————单元测试
    程序构建

    外加 回归测试：有选择地测试一些子集
1. 单元测试
    >验证最小单位（单元）是否按设计运行的测试工作

        单元接口：模块提供给外界调用的能力
        单元接口测试：数据流测试、内外存交换测试

        局部数据结构
        重要执行通路：最可能发生错误的、最有代表性的
        错误处理路径
        边界条件：在边界处常容易出错
    单元测试环境搭建

        驱动模块：模拟调用、上一级模块
        桩模块（存根）：模拟被调用、下一级模块
2. 集成测试
    
    利用通过单元测试的构件建立设计中描述的程序结构，检测多个软件单元是否按概要说明的方式协同工作

    非渐增测试：分别测试、一次集成

    渐增测试：一个测完再测下一个

        渐增的自顶向下：
            主控模块开始
            广度优先、深度优先
        渐增的自底向上：
            原子模块开始
            广度优先
3. 验收测试

   站在用户角度、有用户参与测试，检查系统是否满足合同中定义的需求
4. 系统测试
   
    恢复测试
    安全测试
    压力测试
    性能测试
    部署测试
## 软件项目管理
### 软件项目管理概念
#### 项目管理的4P要素——人员、产品、过程、项目
- 人员：高级管理者、项目管理者、开发人员、客户、最终用户
- 产品：环境、目标、性能
- 过程：沟通、策划、建模、构建、部署
- 项目：正确基础-保持动力-跟踪进展-良好决策-事后分析
### 软件度量和估算
度量是估算的基础，是估算的一个环节

度量侧重代码本身

估算侧重人的因素
#### 软件项目度量
软件生产率

软件质量

度量方法：面向规模（代码行数）、面向功能（代码功能）

面向规模度量指标

    千行代码：KLOC
    生产率：PM（千行/人月）
    人月PM：一个人做一个月
    千行代码平均成本CKL
    代码出错率EQRL
    文档与代码比DL
面向功能度量指标:功能点FP<br>计算方法
$$
FP=UFC*TCF
$$
UFC：未调整功能点计数<br>TCF：技术复杂度因子
$$
UFC=\sum xp加权
$$
$$
TCF=0.65+0.01*D1
$$
来自历史数据拟合
#### 软件项目估算
基于分解技术和回归分析

*基于分解技术*

问题分解估算（三点期望值法）<br>估算代码行、功能点

    估计最大值、最小值、最可能值进行加权平均
$$
估计期望=（最大值+4*最可能值+最小值）/6
$$

*基于回归分析*

利用指数模型$E=A+B*e_v^C$<br>其中ABC是经验常量，$e_v$是估算变量，E是工作量

计算功能点则一般是线性拟合

**估算开发时间**
并不是得到工作量就能知道开发时间

利用指数经验模型拟合

**COCOMO模型**——构造性成本模型

基本cocomo
$$
E=a*(KLOC)^b
$$
$$
T=c*E^d
$$
a,b,c,d均是根据类型有不同的经验常数
### 项目计划
#### 甘特图Gantt Chart
横轴时间、纵轴任务
#### 任务网络图
有向、带权图，结点表示任务、权值代表时间

关键路径：完成项目最长的路径即是关键路径<br>制约完成项目的最快时间、有时不止一条

关键路径并不是唯一决定的因素，还要考虑资源的可用性

    在纯并行策略因为人力达不到无法执行时，可以采用串并行组合模式
# 考试相关
程序阅读题范围：java 1~9章（包含I/O流）

编程题：java 4~7章

简答题/计算题：软工 13、14、18章（软件工程概述、软件过程、项目管理）

分析题：软工 15、16、17章（需求分析、软件设计、质量保证）

无程序实践和软件维护

无结构化建模
## Java（无简答题）
### Java概述
Java源文件及其编译运行、JVM
### 基本语法
关键字、标识符

数据类型转换

布尔短路逻辑运算符
### 基本结构
顺序、条件、循环

数组：引用传递，初始化

switch-case-default注意break
### 类和对象
多态：父类和子类行为、编译类型和运行类型

重载和覆盖（继承场景中）

构造方法：super构造、静态构造
### 继承
抽象类和抽象方法abstract

null/this/super

终结类和终结方法final
### 包、访问控制和接口
package import

public/protected/(default)/private
### 异常处理
throw语句直接抛出对象

throws作为方法的声明（接口也可能声明异常）

构造方法和异常处理结合
### 多线程
继承Thread

实现runable接口（传入Thread对象）

同步方法和同步块synchronized
### I/O流
流：读流、写流；字节（按Byte）流、字符（按有意义的字符分）流；缓冲流；数据转换流；scan方法，file类
## 软件工程
### 软件概念和特点
程序+数据（数据结构）+文档

既是产品也是工具

软件危机概念和原因

应用软件工程的原因：消除软件危机

软件工程定义：应用系统化、规范化、可量化的方法开发、运行、维护软件

三要素：方法、工具、过程
### 软件过程
定义：活动、任务、动作的集合

五大过程模型：瀑布、增量、原型、螺旋（应对风险）、敏捷<br>宁小勿大

用例图、活动图
### 系统设计
顺序图、分析/设计类图

消息划分、指向

### 测试
白盒：逻辑覆盖

黑盒：等价类
### 项目管理——人员产品项目过程4p
软件度量：生产率（代码行/规模、功能点）、工作量cocomo……

三点期望法

任务网络图找关键路径

甘特图
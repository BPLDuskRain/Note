# 编译原理
## 编译概述
高级语言（编写效率高）——编译至汇编/机器<br>
汇编语言（助记符、依赖机器、效率低）——汇编至机器<br>机器语言（机器码01）

源程序——预处理——编译器——汇编器——链接器——目标机器

- 汇编器会得到**可重定位**的目标机器代码
  
    可重定位是指起始位置不固定（内存中位置）
### 编译系统结构
1. 词法分析
2. 语法分析
3. 语义分析
4. 中间代码生成、优化
5. 目标代码生成、优化
- 在分析中可以得到一种中间表示，它是独立于具体语言的桥梁
- 词法分析：确定句子中各个单词的词性
- 语法分析：识别短语
### 词法分析介绍
编译的第一个阶段

任务：逐行扫描源程序字符，将其转换成token标识

token：<种别码，属性值>
#### 单词类型
|类型|种别|种别码|
|-|-|-|
|关键字|while/if/else……|一词一码|
|标识符IDN|变量名/数组名……|多词一码|
|常量CONST|整型/浮点型/字符型/布尔型……|一型一码|
|运算符|算术/关系/逻辑|一词一码/一型一码|
|界限符|；()={}……|一词一码|

关键字/界限符（一词一码）不需要种别码
常量种别码存值、标识符种别码存名字
### 语法分析介绍
从token中识别出各类短语并构造语法分析树AST
#### 文法
一系列生成规则

->:生成
|:逻辑或
### 语义分析介绍
- 收集标志符的属性信息
  - 种属
  - 类型
  - 存储位置和长度
  - 值
  - 作用域
  - 参数和返回值
- 并存入被称作符号表的数据结构
  - 符号表常常还带着字符串表来存储标志符
- 语义检查：
  - 未声明
  - 重复声明
  - 运算类型不匹配
  - 操作符和操作符类型不匹配
### 中间代码生成
常用的表示形式有
- 三地址码
- 语法结构树
#### 三地址码
地址可以是
- 名字——来自源程序
- 常量
- 临时变量——编译器生成

|序号|指令类型|指令形式|注释|
|-|-|-|-|
|1|赋值|x = y op z|op是二元运算符|
|||x = op y|op是一元运算符|
|2|复制|x = y|
|3|条件跳转|if x relop y goto n|relop是布尔运算符|
|4|跳转|goto n|n是地址|
|5|参数传递|param x|将x设置为参数|
|6|过程调用|call p,n|p是过程名字，n是参数个数|
|7|过程返回|return x|x是地址|
|8|数组引用|x = y[i]|y是基地址，i是偏移地址|
|9|数组赋值|x[i]=y||
|10|地址、指针操作|x=&y, x=*y, *x=y||

可以使用四元式、三元式、间接三元式表示
#### 三地址指令表示——以四元式为例
在四元式中，将操作符放在第一位，通常将目的数放在最后一位
## 简单编译器实现
**词法规则**将字符组成终结符

    ID->[a-zA-Z][a-zA-Z0-9]
**语法规则**将终结符和非终结符组成语句

    while_stmt->while(bool_expr)stmt
    bool_expr->expr==expr|expr>expr|expr<expr
### 词法分析器
识别标识符、关键字、运算符、分界符、常量等**终结符**

输入字符串形式的源代码

输出带标记的子串
#### 状态转换图法（手动编写）
所需函数

    取字符
    判断当前符号
    关键字检查
    加入已识别字符串
    跳过空格和注释
### 语法分析器
检查输入是否满足语法规则

生成语法分析树

为了对应语法规则和源代码有以下两种思想
#### 递归下降——从语法规则出发
为每一个非终结符构建解析函数

需求函数：读入下一个单词，非终结符解析函数，终结符匹配函数
#### 抽象语法树AST建立
节点设计

    左右子树指针
    节点类型
    保存的信息

    创建新节点（数值、标识符、表达式）
需要建立符号表

对于变量，包含变量名、类型、值

对于函数，包含函数名、参数个数、参数类型、返回类型
### 中间代码生成
三地址代码
## 语言和文法
### 字母表$\Sigma$
一个有穷集合，如ascii

可对该集合作集合运算

空串：$\epsilon$

闭包：长度整数的符号串的集合
- 其中正闭包不包含空串

串运算可以连接、幂运算定义为多次连接
### 文法——句子的构成规则
$$
G=(V_t,V_n,P,S)
$$
$V_T$即终结符token集合<br>$V_N$即非终结符（文法成分）集合<br>P即产生式集合，用来产生串<br>S是开始符号（最大的非终结符）

对一组相同左部的产生式，可以合并为一组产生式

#### 终结符
前面的小写字母<br>运算符<br>标点符号<br>数字<br>关键字和id
#### 非终结符
前面的大写字母<br>开始符号S<br>expr、stmt等<br>表达式E，项T，因子F
#### 文法符号
后面的大写字母
#### 终结符号串
后面的小写字母
#### 文法符号串
小写希腊字母
### 推导和规约——生成语言和识别语言
推导：根据产生式将左值替换为右值（概括到具体）

规约：根据产生式将右值替换为左值（具体到概括）

句型 是一个包含非终结符的符号串

句子 是一个只包含终结符的符号串，一种特殊的句型

语言：G可以生成的全部句子集合L(G)
### 文法分类
#### 0型文法——无限制文法
$$
\alpha->\beta
$$
左部有非终结符就行
#### 1型文法——上下文有关文法CSG
$$
aAa->a\beta a
$$
要求左值个数不能多于右值，即右侧不能是空串
#### 2型文法——上下文无关文法CFG
$$
A->\beta
$$
要求左值必须是单个非终结符
#### 3型文法——正则文法RG
$$
A->\omega B|B\omega|\omega
$$
右值必须包含终结符串
### 上下文无关文法的分析树
根节点：开始符号<br>内部节点：产生式应用

所有叶子结点从左到右排列形成短语

直接短语是仅有二层的简单子树的叶子节点形成的

如果一个文法可以生成多个分析树，则说该文法具有**二义性**<br>通过给出一些消歧规则可以消除二义性
## 词法分析
### 正则表达式RE
空串$\epsilon$和字母当然是正则表达式

正则表达式的计算关系（连接、闭包等）也是正则表达式

正则文法应当和正则表达式等价
### 正则定义RD
封装一些可复用的定义，使其可以和基本构成一样使用

eg.digit=[0-9]
### 有穷自动机FA
具有**一系列离散输入输出**和**有穷个内部状态**（状态记录了部分过去信息）

有穷自动机和正则表达式也是等价的
#### 构成
输入带：存放符号串

读头：只读，单向

有穷控制器：具有可数个状态
#### 转换图
结点（即状态）：

    初始状态：一个，start->⚪
    终止/接收状态：可多个，同心圆表示
    有向边：表示存在转换
#### FA接收
一串输入串进入自动机后，能进入到终止状态
#### 最长子串匹配原则
选择最长的前缀进行匹配：即寻找最终终态
#### 有穷自动机分类
##### 确定有穷自动机DFA（易实现）
$$
M=(S,\Sigma,\delta,s_0,F)
$$
S是有穷状态集<br>$\Sigma$是字母表（不包括空串$\epsilon$）<br>$\delta$是函数：$\delta(s,a)$表示s为当前开始、a为当前输入<br>$s_0$是初始状态<br>F是终止状态

一个确定有穷自动机可以通过转换表表示转换图（等价）
##### 非确定有穷自动机NFA（直观）
和DFA的区别在于函数进入一个集合而非某个确定的值

###### 带有空串边的NFA
空边表示可以进入下一状态，但其接收并不一致

然而这与不带空边的NFA也是等价的
#### 正则表达式转换到有穷自动机
RE->NFA->DFA
##### RE->NFA
$\epsilon/a$：start->⚪-$\epsilon/a$->@

连接：串联<br>逻辑或：并联<br>闭包：反身
##### NFA->DFA
由转换表容易解析（带$\epsilon$转换图需要更谨慎地解析到转换表）

初始状态不变<br>使用集合替代同输入分支<br>
#### 词法错误
单词拼写/非法字符

当转换表为空时报错
##### 错误恢复
恐慌模式：在接下来的输入流中删到能识别为止
## 自顶向下的语法分析
从文法开始符号S**推导**出词串w
- 最左推导（对应最右规约）：选择最左非终结符进行替换
- 最右/规范推导（对应最左/规范规约）：选择最右非终结符进行替换
- 最左和最有推导具有唯一性
- 自顶向下语法分析采用最左推导（左->右扫描导致的）
- 自顶向下的通用形式是递归下降
  - 遇到不确定时需要回溯（不确定分析）
  - 不需要回溯称为预测分析，LL(k)文法即可以预测k个输入符号
### 文法转换
#### 消除左递归（包括直接和间接）
左递归文法会使递归下降陷入循环（由最左推导导致）
##### 直接左递归
找出正则表达式，写出不含左递归的等价产生式（左递归转右递归）<br>代价是引入了新终结符、产生式和空串

若有一个直接左递归$A->A\alpha|\beta$

其对应的右递归形式为
$$
A->\beta|A^`;A^`->\alpha A^`|\epsilon
$$
##### 间接左递归
将会产生间接左递归的产生式进行代入，构造直接左递归，再消除直接左递归
#### 消除公共前缀（提取公因子）
遇到同样的产生式输入，通过提取左公因子进行推迟决定
### LL(1)文法——左向扫描、最左推断、预测一个
可以使用预测分析，不需要回溯
#### S文法
产生式右值以终结符开始，且分支首终结符不同（无空产生式）

这样只会选出一个候选式子，但S文法不包含空产生式

空产生式的引入造成了是否使用、什么时候使用的问题
#### LL(1)文法定义
- 即对于多分支产生式，可选集是无交集的
- 多分支的FIRST集不相交，空产生式推到FOLLOW集和FIRST集不相交
### FIRST集和FOLLOW集
FIRST集是进行产生式推导后可能出现的所有首终结符的集合，包含空串

FOLLOW集是紧跟在非终结符后的所有可能的终结符的集合，另加一结束符$

容易得出可选集为

    没有空串的FIRST集/
    除去空串的FIRST集并上FOLLOW集
#### FIRST集计算
若是终结符直接计入

非终结符直接把其FIRST集计入，出现空串继续递归

只有空串计入空串
#### FOLLOW集计算
多重更新计算
### 递归下降
#### 一般过程

    GETNEXT(TOKEN);
    PROGRAM(TOKEN);//对起始符号进行解析
    GETNEXT(TOKEN);//不为结束符则报错
#### 产生式分析
通过产生式一一匹配，匹配完继续获得token，匹配失败则报错

固定部分（终结符）固定匹配

非终结符继续调用非终结符的函数

1. 输入token
2. 将token进行分析
   1. 若是终结符则if固定分析，不是则报错
   2. 若是非终结符，则调用对应的非终结符分析函数
3. 再次调用token
### 预测分析（非递归、表驱动）
通过下推自动机制表，下推自动机通过压栈存储前符号

    制表——化产生式为表：
    列表头非终结符，行表头终结符，存放展开式或出错标志

    分别列出栈和剩余输入
    从栈顶符号开始分析
        终结符直接比对，对上即出栈（终结符和输入都出栈）
        非终结符继续分析
    分析：当遇到输入时，产生式如何选择（查表得）。产生式左部出栈，右部入栈（左侧在栈顶）

当栈和输入均只剩$（栈底标记/结束标志）时，分析结束

    表来自FIRST集和FOLLOW集构造
    非终结符FIRST集无空全部匹配，空匹配其FOLLOW集
    若FIRST集和FOLLOW集有交集，则不属于LL1文法

递归分析程序规模大、效率低、自动生成难，但直观性好；非递归程序规模小（需求表）、分析时间和待分析程序成正比、自动生成易，但直观性差
#### 错误处理
终结符不匹配/非终结符与输出符号

仍然采用恐慌模式，抛弃输入流，直到遇到同步词法单元

    同步词法单元：  
        由设计者选取，能使错误快速恢复
        在不存在空产生式的情况下一般选择FOLLOW集
遇到同步词法单元后抛弃栈顶元素
## 自底向上的语法分析（最左规约）
    从输入串开始逐步“归约”
### 移入——归约分析
将剩余输入挨个入栈，能匹配产生式则进行归约，不能则继续入栈
### LR分析法——关键在于识别句柄
>对于一个文法能构造有唯一入口的表

从左到右扫描字符串<br>分析栈中符号，向前搜索确定栈内是否出现句柄<br>
剪枝:剪断后仍然是一棵树<br>移进和归约可能存在冲突，归约和归约也可能存在冲突（使用策略）<br>如何判断已经形成可归约串<br>直接短语：最下树<br>句柄：最左直接短语

    句型变化则句柄变化——句柄确定语法树
LR(K)分析，K=0/1

    移进：压栈
    规约：检查并替换
    成功：栈内只有栈底和文法开始符号
    出错
状态栈：符号栈和状态栈同步<br>分析表：action, goto两个子表

    action[s,a]:状态s下，输入a，查表查询动作（移进shift，归约reduce，接受accept，报错error）
    goto[s,X]:状态s下，规约后的X入栈的状态，查表
分析表严重依赖表达式编号，因此应该先对表达式编号
>分析表构造

>活前缀<br>
栈内符号+剩余串一定是一个规范句型<br>栈内句柄一定在其顶部（出现即规约）<br>句柄之后总是终结符<br>栈中字符串称为前缀<br>而不包含句柄/包含句柄的一部分（此时期待移进整个句柄）/结尾为句柄的前缀称为活前缀<br>活前缀存在则可继续移进

>项目<br>
规约项目<br>移进项目:后为终结符<br>待约项目：后为非终结符<br>接收项目：规约为开始符号<br>

>拓广文法<br>
多出口合并，只拥有唯一的接收项目

- 构造方法

    
### 算符优先分析法
>非终结符不连续出现

- 算符优先关系：算符等，算符大，算符小（左右有别，不对称）通过这种关系确定谁应当先被规约
- 若算符文法G中任意的一对终结符满足一种算符优先关系，则是算符优先分析法

算符优先关系表中：

    终结符中无优先关系称为错误

分析规则:

    1.栈顶优先级低或等于，则移进下一符号
    2.栈顶优先级高，则规约

分析进程：

    移进
    根据分析规则移进或规约
    比较时只比较未规约部分

### SLR(1)文法
在LR(0)文法出现二义性的时候，向前展望一个字符
>假使有$S->\alpha·aA$, $A->\alpha·$, $B->\alpha·$

    则需要a，FOLLOW(A), FOLLOW(B)没有交集才能解决冲突

### LR分析中的错误处理
错误：输入符号不能移进，栈内符号不能规约<br>处理：插入、删除、修改/在源代码中去掉一段

### 小结
文法和语法<br>上下文无关文法<br>推导和规约<br>语法树
>自上而下的语法分析

    带回溯的分析方法——左递归、公共左因子、空表达式
    FIRST集，FOLLOW集，LL(1)文法
    递归下降分析
    预测分析法
>自下而上的语法分析

    规范推导、规范规约
    短语、直接短语、句柄
    LR(0)，SLR(1)
## 语义分析
对**结构上正确**的程序进行语义审查
### 语义
静态语义（编译时可以做检查）：

    语法规则的良形式条件（合理情况），包括：
        类型规则
        作用域/可见性规则
    如类型检查，控制流检查，唯一性检查，关联名字检查（如构造函数），一致性检查，名字的作用域分析

静态分析环境
>提供作用域和类型信息

    生成类型、作用域、存储类别、存储位置（相对）等

通过yacc(Bison)提供对语法翻译制导的支持

#### 符号表
>一种保存源程序构造的数据结构

    符号名、符号类型、地址码、层次信息、行号信息、存储类别、存储位置

>作用：将信息从声明的地方传递到使用的地方

#### 语义分析方法：语法制导分析
不建立抽象语法树，直接生成中间代码（适用于文法简单的语言）

属性文法：通过属性赋值分析语义

    在推导语法树时，属性的值被计算并层层传递，推导完成后就得到程序语义
    其属性值依赖其父节点和兄弟节点，通过依赖图给出
    语义子程序可直接转写语法分析进行语法制导翻译（描述产生式对应的翻译工作）
    在创建AST时，传递数值只需要指针操作
    
语义变量

    i.name表示终结符i对应的标识符字符串
    E.place表示非终结符E在符号表的位置（临时编码则是进行整数编码）
语义函数

    newtemp()产生一个新的临时变量并返回其地址（或编码）
    entry(i.name)对i.name查表返回位置
    emit()产生四元式并入表

源程序由符号表和关键字组成

语句翻译设计要点：

    确定语句目标结构
        说明语句：定义各类名字的属性
        简单赋值语句：A=B
        布尔表达式：
        条件语句：if T goto ...(真跳转)
                    goto ...（假跳转）
        循环语句：
动态语义

### 代码优化
要求：
    等价变换
    提高运行速度
    减少代码空间
#### 中间代码优化
基本块优化
>基本块：一段连续的顺序执行语句（单出口单入口）

    确定入口语句：
        第一条语句
        转移语句（goto）转移到的语句
        紧随条件转移语句（if goto）的语句
两条入口语句之间是一个基本块（删除不在基本块内的代码），然后连接代码块

    删除无用代码
        不可到达代码（不被执行）
        死变量（未被使用）
        死代码（对执行结果无作用）
        死块（控制流无法到达）
    删除公共子表达式
        即运算改赋值（运算数不变）
    复写传播
        赋值后二值均未变化，可以直接变量代替（删除新变量）
    代数恒等变换
        合并已知量：编译期常量直接确定
        常数传播：已知变量代替相等的未知变量
        削弱计算强度：代数等价替换，快运算换慢运算（如乘法变加法）充分使用交换律结合律，利用已经定值的变量
        改变计算次序：当改变次序不影响结果时，改变次序有时会优化寄存器存储
DAG

    使代码优化更直接、易读
DAG生成

    每个节点有一个标记：标识符（右值）/常数（叶子节点），运算符（内部节点）
    可以有副标：副标为标识符左值
循环优化
>确定循环：唯一头节点、强连通性

    代码外提:将不变运算置于循环外计算（需要检查外提后结果是否变化——可能根本不进入循环！）
        不变运算是指在循环中不论循环几次结果都不变的运算
    所在节点是循环所有出口的必经节点

    强度削弱：代数等价替换，快运算换慢运算

    删除归纳变量：循环时，有基本归纳变量和递增不变量。
    当归纳变量互相关联时（同族）可以用一个变量替换另一个变量
目标代码生成：中间代码（经过语法分析、语义检查，和源程序等价）和符号表（记录了和名字有关的信息、数据对象的相对地址）
>目标代码有绝对地址形式、可重定位（.obj/.o文件）、汇编语言程序

目标代码生成程序的具体细节依赖于目标机器和操作系统，考虑：

    存储管理、指令选择、寄存器分配、计算次序选择
#### 寄存器分配
对于寄存器分配，需要分析信息的待用和活跃性，将数量几乎无限的虚拟寄存器映射到数量有限的物理寄存器

    原则上将用得最多的、最近要用的放在寄存器里
图着色算法：

    基本概念：
        生存期：赋值到最后一次被引用的时间段
        图着色：生存期作为定点，生存期有重复（即冲突）定义成边。每个顶点一个颜色、相邻的顶点不能使用同样的颜色
        根据冲突个数由低到高去掉冲突，直到只剩一个节点，开始反向着色
线性扫描算法：

    生存期分析
    根据开始时间排序放入（按定义时间）寄存器，以active表表示。在寄存器不够时，优先把长生存周期变量写入内存，以spill表表示。
    根据结束时间挨个移除变量
#### 寄存器描述、地址描述
描述寄存器占用情况

    待用信息：等待被引用的变量
    活跃信息：正在使用的变量、经常使用的变量——尽量在寄存器里，剩余寄存器存放局部变量
指令执行代价：

    访问内存单元次数+1
    用于评价变量是否经常使用
$$
S=(\sum Refer(X,B)+2*Live(X,B))A-4
$$

    Refer:B定值X前被使用的次数（使用上个块中的赋值）
    Live:X在B之后是否存活/活跃，活跃返回1
    A:X被使用的概率
    活跃变量需要存到内存方便下一个基本块使用
## 运行时环境
### 运行流程
操作系统OS为程序分配存储空间、代码复制、跳转入口地址
### 存储的组织和管理
（低地址）代码区->静态数据区->堆区->空闲空间->栈区（高地址）

    代码区：存放目标代码
    静态数据区：编译时可确定大小的数据（一般生存周期较长）
    堆区：存放动态数据
    栈区：存放活动记录
#### 函数活动
函数一次执行称为一次函数活动

函数执行需要 可执行代码和存放信息的数据结构<br>通过活动记录来管理（多个调用对应多个活动记录——使用栈来管理多个活动记录）
#### 活动记录
一个活动需要的信息组织成一个连续的存储空间，称为活动记录

    返回地址：一个地址，存放返回单元的位置（x调用，返回到x+1。因此存储调用之后的下一条指令的地址）
    动态链接（控制链）：调用单元最新的活动记录（调用者活动记录首地址）
    静态链接（访问链）：非局部变量所在的活动记录（定义该函数的位置）
    现场保护：状态信息
    局部变量
    临时变量
    参数个数（实参）
    形式单元（形参）
活动记录的位移：D（首地址）+offset(i)（偏移量）

    静态变量：D和offset(i)在编译时都能确定
    半静态变量：offset(i)编译确定、D运行时确定（大小确定位置不确定）
    半动态变量：D和offset(i)编译不确定、但运行能确定（控制流导致）
    动态变量：D和offset(i)运行时也不能确定
#### 静态变量
所有数据存储位置固定：不支持递归调用<br>运行时无存储分配：不支持动态数据结构
#### 半静态变量
编译可确定活动记录长度：支持多次激活、支持递归调用

一般用栈实现存储其活动记录
#### 半动态变量
动态分配在栈顶，生存周期和函数绑定（每次运行函数才能确定）
#### 动态变量
使用堆存储

可保存需要的值，如使用指针、文件等
#### 函数调用
调用需要保证能够返回、准确设置活动记录指针、返回所需指针、准确的嵌套作用域……

处理步骤

    设置当前栈指针current（首地址）
    free表示下一个可用单元，free = current + L
    （开始调用）
    被调用单元保存返回地址
    被调用单元保存调用单元的current
    更新current成为被调用单元的current（操作中将free赋值给current）
    调整free：free = current + L
    （活动记录完成）
    转移到P（即被调用函数的第一条代码，开始执行被调用函数）
    （执行完毕，开始返回）
    调整free：free = current
    还原current
    （继续执行调用者后续代码）
